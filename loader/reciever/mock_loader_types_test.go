// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package reciever

import (
	"github.com/ozontech/framer/loader/types"
	"golang.org/x/net/http2"
	"sync"
)

// Ensure, that StreamStoreMock does implement types.StreamStore.
// If this is not the case, regenerate this file with moq.
var _ types.StreamStore = &StreamStoreMock{}

// StreamStoreMock is a mock implementation of types.StreamStore.
//
//	func TestSomethingThatUsesStreamStore(t *testing.T) {
//
//		// make and configure a mocked types.StreamStore
//		mockedStreamStore := &StreamStoreMock{
//			DeleteFunc: func(v uint32)  {
//				panic("mock out the Delete method")
//			},
//			EachFunc: func(fn func(types.Stream))  {
//				panic("mock out the Each method")
//			},
//			GetFunc: func(v uint32) types.Stream {
//				panic("mock out the Get method")
//			},
//			GetAndDeleteFunc: func(v uint32) types.Stream {
//				panic("mock out the GetAndDelete method")
//			},
//			SetFunc: func(v uint32, stream types.Stream)  {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedStreamStore in code that requires types.StreamStore
//		// and then make assertions.
//
//	}
type StreamStoreMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(v uint32)

	// EachFunc mocks the Each method.
	EachFunc func(fn func(types.Stream))

	// GetFunc mocks the Get method.
	GetFunc func(v uint32) types.Stream

	// GetAndDeleteFunc mocks the GetAndDelete method.
	GetAndDeleteFunc func(v uint32) types.Stream

	// SetFunc mocks the Set method.
	SetFunc func(v uint32, stream types.Stream)

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// V is the v argument value.
			V uint32
		}
		// Each holds details about calls to the Each method.
		Each []struct {
			// Fn is the fn argument value.
			Fn func(types.Stream)
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// V is the v argument value.
			V uint32
		}
		// GetAndDelete holds details about calls to the GetAndDelete method.
		GetAndDelete []struct {
			// V is the v argument value.
			V uint32
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// V is the v argument value.
			V uint32
			// Stream is the stream argument value.
			Stream types.Stream
		}
	}
	lockDelete       sync.RWMutex
	lockEach         sync.RWMutex
	lockGet          sync.RWMutex
	lockGetAndDelete sync.RWMutex
	lockSet          sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *StreamStoreMock) Delete(v uint32) {
	if mock.DeleteFunc == nil {
		panic("StreamStoreMock.DeleteFunc: method is nil but StreamStore.Delete was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	mock.DeleteFunc(v)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedStreamStore.DeleteCalls())
func (mock *StreamStoreMock) DeleteCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Each calls EachFunc.
func (mock *StreamStoreMock) Each(fn func(types.Stream)) {
	if mock.EachFunc == nil {
		panic("StreamStoreMock.EachFunc: method is nil but StreamStore.Each was just called")
	}
	callInfo := struct {
		Fn func(types.Stream)
	}{
		Fn: fn,
	}
	mock.lockEach.Lock()
	mock.calls.Each = append(mock.calls.Each, callInfo)
	mock.lockEach.Unlock()
	mock.EachFunc(fn)
}

// EachCalls gets all the calls that were made to Each.
// Check the length with:
//
//	len(mockedStreamStore.EachCalls())
func (mock *StreamStoreMock) EachCalls() []struct {
	Fn func(types.Stream)
} {
	var calls []struct {
		Fn func(types.Stream)
	}
	mock.lockEach.RLock()
	calls = mock.calls.Each
	mock.lockEach.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *StreamStoreMock) Get(v uint32) types.Stream {
	if mock.GetFunc == nil {
		panic("StreamStoreMock.GetFunc: method is nil but StreamStore.Get was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(v)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedStreamStore.GetCalls())
func (mock *StreamStoreMock) GetCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAndDelete calls GetAndDeleteFunc.
func (mock *StreamStoreMock) GetAndDelete(v uint32) types.Stream {
	if mock.GetAndDeleteFunc == nil {
		panic("StreamStoreMock.GetAndDeleteFunc: method is nil but StreamStore.GetAndDelete was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockGetAndDelete.Lock()
	mock.calls.GetAndDelete = append(mock.calls.GetAndDelete, callInfo)
	mock.lockGetAndDelete.Unlock()
	return mock.GetAndDeleteFunc(v)
}

// GetAndDeleteCalls gets all the calls that were made to GetAndDelete.
// Check the length with:
//
//	len(mockedStreamStore.GetAndDeleteCalls())
func (mock *StreamStoreMock) GetAndDeleteCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockGetAndDelete.RLock()
	calls = mock.calls.GetAndDelete
	mock.lockGetAndDelete.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *StreamStoreMock) Set(v uint32, stream types.Stream) {
	if mock.SetFunc == nil {
		panic("StreamStoreMock.SetFunc: method is nil but StreamStore.Set was just called")
	}
	callInfo := struct {
		V      uint32
		Stream types.Stream
	}{
		V:      v,
		Stream: stream,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(v, stream)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedStreamStore.SetCalls())
func (mock *StreamStoreMock) SetCalls() []struct {
	V      uint32
	Stream types.Stream
} {
	var calls []struct {
		V      uint32
		Stream types.Stream
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// Ensure, that StreamMock does implement types.Stream.
// If this is not the case, regenerate this file with moq.
var _ types.Stream = &StreamMock{}

// StreamMock is a mock implementation of types.Stream.
//
//	func TestSomethingThatUsesStream(t *testing.T) {
//
//		// make and configure a mocked types.Stream
//		mockedStream := &StreamMock{
//			EndFunc: func()  {
//				panic("mock out the End method")
//			},
//			FCFunc: func() types.FlowControl {
//				panic("mock out the FC method")
//			},
//			GoAwayFunc: func(code http2.ErrCode)  {
//				panic("mock out the GoAway method")
//			},
//			IDFunc: func() uint32 {
//				panic("mock out the ID method")
//			},
//			IoErrorFunc: func(err error)  {
//				panic("mock out the IoError method")
//			},
//			OnHeaderFunc: func(name string, value string)  {
//				panic("mock out the OnHeader method")
//			},
//			RSTStreamFunc: func(code http2.ErrCode)  {
//				panic("mock out the RSTStream method")
//			},
//			SetSizeFunc: func(n int)  {
//				panic("mock out the SetSize method")
//			},
//		}
//
//		// use mockedStream in code that requires types.Stream
//		// and then make assertions.
//
//	}
type StreamMock struct {
	// EndFunc mocks the End method.
	EndFunc func()

	// FCFunc mocks the FC method.
	FCFunc func() types.FlowControl

	// GoAwayFunc mocks the GoAway method.
	GoAwayFunc func(code http2.ErrCode)

	// IDFunc mocks the ID method.
	IDFunc func() uint32

	// IoErrorFunc mocks the IoError method.
	IoErrorFunc func(err error)

	// OnHeaderFunc mocks the OnHeader method.
	OnHeaderFunc func(name string, value string)

	// RSTStreamFunc mocks the RSTStream method.
	RSTStreamFunc func(code http2.ErrCode)

	// SetSizeFunc mocks the SetSize method.
	SetSizeFunc func(n int)

	// calls tracks calls to the methods.
	calls struct {
		// End holds details about calls to the End method.
		End []struct {
		}
		// FC holds details about calls to the FC method.
		FC []struct {
		}
		// GoAway holds details about calls to the GoAway method.
		GoAway []struct {
			// Code is the code argument value.
			Code http2.ErrCode
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// IoError holds details about calls to the IoError method.
		IoError []struct {
			// Err is the err argument value.
			Err error
		}
		// OnHeader holds details about calls to the OnHeader method.
		OnHeader []struct {
			// Name is the name argument value.
			Name string
			// Value is the value argument value.
			Value string
		}
		// RSTStream holds details about calls to the RSTStream method.
		RSTStream []struct {
			// Code is the code argument value.
			Code http2.ErrCode
		}
		// SetSize holds details about calls to the SetSize method.
		SetSize []struct {
			// N is the n argument value.
			N int
		}
	}
	lockEnd       sync.RWMutex
	lockFC        sync.RWMutex
	lockGoAway    sync.RWMutex
	lockID        sync.RWMutex
	lockIoError   sync.RWMutex
	lockOnHeader  sync.RWMutex
	lockRSTStream sync.RWMutex
	lockSetSize   sync.RWMutex
}

// End calls EndFunc.
func (mock *StreamMock) End() {
	if mock.EndFunc == nil {
		panic("StreamMock.EndFunc: method is nil but Stream.End was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEnd.Lock()
	mock.calls.End = append(mock.calls.End, callInfo)
	mock.lockEnd.Unlock()
	mock.EndFunc()
}

// EndCalls gets all the calls that were made to End.
// Check the length with:
//
//	len(mockedStream.EndCalls())
func (mock *StreamMock) EndCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEnd.RLock()
	calls = mock.calls.End
	mock.lockEnd.RUnlock()
	return calls
}

// FC calls FCFunc.
func (mock *StreamMock) FC() types.FlowControl {
	if mock.FCFunc == nil {
		panic("StreamMock.FCFunc: method is nil but Stream.FC was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFC.Lock()
	mock.calls.FC = append(mock.calls.FC, callInfo)
	mock.lockFC.Unlock()
	return mock.FCFunc()
}

// FCCalls gets all the calls that were made to FC.
// Check the length with:
//
//	len(mockedStream.FCCalls())
func (mock *StreamMock) FCCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFC.RLock()
	calls = mock.calls.FC
	mock.lockFC.RUnlock()
	return calls
}

// GoAway calls GoAwayFunc.
func (mock *StreamMock) GoAway(code http2.ErrCode) {
	if mock.GoAwayFunc == nil {
		panic("StreamMock.GoAwayFunc: method is nil but Stream.GoAway was just called")
	}
	callInfo := struct {
		Code http2.ErrCode
	}{
		Code: code,
	}
	mock.lockGoAway.Lock()
	mock.calls.GoAway = append(mock.calls.GoAway, callInfo)
	mock.lockGoAway.Unlock()
	mock.GoAwayFunc(code)
}

// GoAwayCalls gets all the calls that were made to GoAway.
// Check the length with:
//
//	len(mockedStream.GoAwayCalls())
func (mock *StreamMock) GoAwayCalls() []struct {
	Code http2.ErrCode
} {
	var calls []struct {
		Code http2.ErrCode
	}
	mock.lockGoAway.RLock()
	calls = mock.calls.GoAway
	mock.lockGoAway.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *StreamMock) ID() uint32 {
	if mock.IDFunc == nil {
		panic("StreamMock.IDFunc: method is nil but Stream.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedStream.IDCalls())
func (mock *StreamMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// IoError calls IoErrorFunc.
func (mock *StreamMock) IoError(err error) {
	if mock.IoErrorFunc == nil {
		panic("StreamMock.IoErrorFunc: method is nil but Stream.IoError was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockIoError.Lock()
	mock.calls.IoError = append(mock.calls.IoError, callInfo)
	mock.lockIoError.Unlock()
	mock.IoErrorFunc(err)
}

// IoErrorCalls gets all the calls that were made to IoError.
// Check the length with:
//
//	len(mockedStream.IoErrorCalls())
func (mock *StreamMock) IoErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockIoError.RLock()
	calls = mock.calls.IoError
	mock.lockIoError.RUnlock()
	return calls
}

// OnHeader calls OnHeaderFunc.
func (mock *StreamMock) OnHeader(name string, value string) {
	if mock.OnHeaderFunc == nil {
		panic("StreamMock.OnHeaderFunc: method is nil but Stream.OnHeader was just called")
	}
	callInfo := struct {
		Name  string
		Value string
	}{
		Name:  name,
		Value: value,
	}
	mock.lockOnHeader.Lock()
	mock.calls.OnHeader = append(mock.calls.OnHeader, callInfo)
	mock.lockOnHeader.Unlock()
	mock.OnHeaderFunc(name, value)
}

// OnHeaderCalls gets all the calls that were made to OnHeader.
// Check the length with:
//
//	len(mockedStream.OnHeaderCalls())
func (mock *StreamMock) OnHeaderCalls() []struct {
	Name  string
	Value string
} {
	var calls []struct {
		Name  string
		Value string
	}
	mock.lockOnHeader.RLock()
	calls = mock.calls.OnHeader
	mock.lockOnHeader.RUnlock()
	return calls
}

// RSTStream calls RSTStreamFunc.
func (mock *StreamMock) RSTStream(code http2.ErrCode) {
	if mock.RSTStreamFunc == nil {
		panic("StreamMock.RSTStreamFunc: method is nil but Stream.RSTStream was just called")
	}
	callInfo := struct {
		Code http2.ErrCode
	}{
		Code: code,
	}
	mock.lockRSTStream.Lock()
	mock.calls.RSTStream = append(mock.calls.RSTStream, callInfo)
	mock.lockRSTStream.Unlock()
	mock.RSTStreamFunc(code)
}

// RSTStreamCalls gets all the calls that were made to RSTStream.
// Check the length with:
//
//	len(mockedStream.RSTStreamCalls())
func (mock *StreamMock) RSTStreamCalls() []struct {
	Code http2.ErrCode
} {
	var calls []struct {
		Code http2.ErrCode
	}
	mock.lockRSTStream.RLock()
	calls = mock.calls.RSTStream
	mock.lockRSTStream.RUnlock()
	return calls
}

// SetSize calls SetSizeFunc.
func (mock *StreamMock) SetSize(n int) {
	if mock.SetSizeFunc == nil {
		panic("StreamMock.SetSizeFunc: method is nil but Stream.SetSize was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockSetSize.Lock()
	mock.calls.SetSize = append(mock.calls.SetSize, callInfo)
	mock.lockSetSize.Unlock()
	mock.SetSizeFunc(n)
}

// SetSizeCalls gets all the calls that were made to SetSize.
// Check the length with:
//
//	len(mockedStream.SetSizeCalls())
func (mock *StreamMock) SetSizeCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockSetSize.RLock()
	calls = mock.calls.SetSize
	mock.lockSetSize.RUnlock()
	return calls
}

// Ensure, that FlowControlMock does implement types.FlowControl.
// If this is not the case, regenerate this file with moq.
var _ types.FlowControl = &FlowControlMock{}

// FlowControlMock is a mock implementation of types.FlowControl.
//
//	func TestSomethingThatUsesFlowControl(t *testing.T) {
//
//		// make and configure a mocked types.FlowControl
//		mockedFlowControl := &FlowControlMock{
//			AddFunc: func(n uint32)  {
//				panic("mock out the Add method")
//			},
//			DisableFunc: func()  {
//				panic("mock out the Disable method")
//			},
//			ResetFunc: func(n uint32)  {
//				panic("mock out the Reset method")
//			},
//			WaitFunc: func(n uint32) bool {
//				panic("mock out the Wait method")
//			},
//		}
//
//		// use mockedFlowControl in code that requires types.FlowControl
//		// and then make assertions.
//
//	}
type FlowControlMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(n uint32)

	// DisableFunc mocks the Disable method.
	DisableFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func(n uint32)

	// WaitFunc mocks the Wait method.
	WaitFunc func(n uint32) bool

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// N is the n argument value.
			N uint32
		}
		// Disable holds details about calls to the Disable method.
		Disable []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
			// N is the n argument value.
			N uint32
		}
		// Wait holds details about calls to the Wait method.
		Wait []struct {
			// N is the n argument value.
			N uint32
		}
	}
	lockAdd     sync.RWMutex
	lockDisable sync.RWMutex
	lockReset   sync.RWMutex
	lockWait    sync.RWMutex
}

// Add calls AddFunc.
func (mock *FlowControlMock) Add(n uint32) {
	if mock.AddFunc == nil {
		panic("FlowControlMock.AddFunc: method is nil but FlowControl.Add was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	mock.AddFunc(n)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedFlowControl.AddCalls())
func (mock *FlowControlMock) AddCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Disable calls DisableFunc.
func (mock *FlowControlMock) Disable() {
	if mock.DisableFunc == nil {
		panic("FlowControlMock.DisableFunc: method is nil but FlowControl.Disable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDisable.Lock()
	mock.calls.Disable = append(mock.calls.Disable, callInfo)
	mock.lockDisable.Unlock()
	mock.DisableFunc()
}

// DisableCalls gets all the calls that were made to Disable.
// Check the length with:
//
//	len(mockedFlowControl.DisableCalls())
func (mock *FlowControlMock) DisableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDisable.RLock()
	calls = mock.calls.Disable
	mock.lockDisable.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *FlowControlMock) Reset(n uint32) {
	if mock.ResetFunc == nil {
		panic("FlowControlMock.ResetFunc: method is nil but FlowControl.Reset was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc(n)
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedFlowControl.ResetCalls())
func (mock *FlowControlMock) ResetCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// Wait calls WaitFunc.
func (mock *FlowControlMock) Wait(n uint32) bool {
	if mock.WaitFunc == nil {
		panic("FlowControlMock.WaitFunc: method is nil but FlowControl.Wait was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockWait.Lock()
	mock.calls.Wait = append(mock.calls.Wait, callInfo)
	mock.lockWait.Unlock()
	return mock.WaitFunc(n)
}

// WaitCalls gets all the calls that were made to Wait.
// Check the length with:
//
//	len(mockedFlowControl.WaitCalls())
func (mock *FlowControlMock) WaitCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockWait.RLock()
	calls = mock.calls.Wait
	mock.lockWait.RUnlock()
	return calls
}

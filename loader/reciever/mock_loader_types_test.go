// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package reciever

import (
	"github.com/ozontech/framer/loader/types"
	"golang.org/x/net/http2"
	"sync"
)

// Ensure, that StreamStoreMock does implement types.StreamStore.
// If this is not the case, regenerate this file with moq.
var _ types.StreamStore = &StreamStoreMock{}

// StreamStoreMock is a mock implementation of types.StreamStore.
//
//	func TestSomethingThatUsesStreamStore(t *testing.T) {
//
//		// make and configure a mocked types.StreamStore
//		mockedStreamStore := &StreamStoreMock{
//			DeleteFunc: func(v uint32)  {
//				panic("mock out the Delete method")
//			},
//			EachFunc: func(fn func(types.Stream))  {
//				panic("mock out the Each method")
//			},
//			GetFunc: func(v uint32) types.Stream {
//				panic("mock out the Get method")
//			},
//			GetAndDeleteFunc: func(v uint32) types.Stream {
//				panic("mock out the GetAndDelete method")
//			},
//			SetFunc: func(v uint32, stream types.Stream)  {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedStreamStore in code that requires types.StreamStore
//		// and then make assertions.
//
//	}
type StreamStoreMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(v uint32)

	// EachFunc mocks the Each method.
	EachFunc func(fn func(types.Stream))

	// GetFunc mocks the Get method.
	GetFunc func(v uint32) types.Stream

	// GetAndDeleteFunc mocks the GetAndDelete method.
	GetAndDeleteFunc func(v uint32) types.Stream

	// SetFunc mocks the Set method.
	SetFunc func(v uint32, stream types.Stream)

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// V is the v argument value.
			V uint32
		}
		// Each holds details about calls to the Each method.
		Each []struct {
			// Fn is the fn argument value.
			Fn func(types.Stream)
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// V is the v argument value.
			V uint32
		}
		// GetAndDelete holds details about calls to the GetAndDelete method.
		GetAndDelete []struct {
			// V is the v argument value.
			V uint32
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// V is the v argument value.
			V uint32
			// Stream is the stream argument value.
			Stream types.Stream
		}
	}
	lockDelete       sync.RWMutex
	lockEach         sync.RWMutex
	lockGet          sync.RWMutex
	lockGetAndDelete sync.RWMutex
	lockSet          sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *StreamStoreMock) Delete(v uint32) {
	if mock.DeleteFunc == nil {
		panic("StreamStoreMock.DeleteFunc: method is nil but StreamStore.Delete was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	mock.DeleteFunc(v)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedStreamStore.DeleteCalls())
func (mock *StreamStoreMock) DeleteCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Each calls EachFunc.
func (mock *StreamStoreMock) Each(fn func(types.Stream)) {
	if mock.EachFunc == nil {
		panic("StreamStoreMock.EachFunc: method is nil but StreamStore.Each was just called")
	}
	callInfo := struct {
		Fn func(types.Stream)
	}{
		Fn: fn,
	}
	mock.lockEach.Lock()
	mock.calls.Each = append(mock.calls.Each, callInfo)
	mock.lockEach.Unlock()
	mock.EachFunc(fn)
}

// EachCalls gets all the calls that were made to Each.
// Check the length with:
//
//	len(mockedStreamStore.EachCalls())
func (mock *StreamStoreMock) EachCalls() []struct {
	Fn func(types.Stream)
} {
	var calls []struct {
		Fn func(types.Stream)
	}
	mock.lockEach.RLock()
	calls = mock.calls.Each
	mock.lockEach.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *StreamStoreMock) Get(v uint32) types.Stream {
	if mock.GetFunc == nil {
		panic("StreamStoreMock.GetFunc: method is nil but StreamStore.Get was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(v)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedStreamStore.GetCalls())
func (mock *StreamStoreMock) GetCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAndDelete calls GetAndDeleteFunc.
func (mock *StreamStoreMock) GetAndDelete(v uint32) types.Stream {
	if mock.GetAndDeleteFunc == nil {
		panic("StreamStoreMock.GetAndDeleteFunc: method is nil but StreamStore.GetAndDelete was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockGetAndDelete.Lock()
	mock.calls.GetAndDelete = append(mock.calls.GetAndDelete, callInfo)
	mock.lockGetAndDelete.Unlock()
	return mock.GetAndDeleteFunc(v)
}

// GetAndDeleteCalls gets all the calls that were made to GetAndDelete.
// Check the length with:
//
//	len(mockedStreamStore.GetAndDeleteCalls())
func (mock *StreamStoreMock) GetAndDeleteCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockGetAndDelete.RLock()
	calls = mock.calls.GetAndDelete
	mock.lockGetAndDelete.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *StreamStoreMock) Set(v uint32, stream types.Stream) {
	if mock.SetFunc == nil {
		panic("StreamStoreMock.SetFunc: method is nil but StreamStore.Set was just called")
	}
	callInfo := struct {
		V      uint32
		Stream types.Stream
	}{
		V:      v,
		Stream: stream,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(v, stream)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedStreamStore.SetCalls())
func (mock *StreamStoreMock) SetCalls() []struct {
	V      uint32
	Stream types.Stream
} {
	var calls []struct {
		V      uint32
		Stream types.Stream
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// Ensure, that StreamsLimiterMock does implement types.StreamsLimiter.
// If this is not the case, regenerate this file with moq.
var _ types.StreamsLimiter = &StreamsLimiterMock{}

// StreamsLimiterMock is a mock implementation of types.StreamsLimiter.
//
//	func TestSomethingThatUsesStreamsLimiter(t *testing.T) {
//
//		// make and configure a mocked types.StreamsLimiter
//		mockedStreamsLimiter := &StreamsLimiterMock{
//			ReleaseFunc: func()  {
//				panic("mock out the Release method")
//			},
//			WaitAllowFunc: func()  {
//				panic("mock out the WaitAllow method")
//			},
//		}
//
//		// use mockedStreamsLimiter in code that requires types.StreamsLimiter
//		// and then make assertions.
//
//	}
type StreamsLimiterMock struct {
	// ReleaseFunc mocks the Release method.
	ReleaseFunc func()

	// WaitAllowFunc mocks the WaitAllow method.
	WaitAllowFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Release holds details about calls to the Release method.
		Release []struct {
		}
		// WaitAllow holds details about calls to the WaitAllow method.
		WaitAllow []struct {
		}
	}
	lockRelease   sync.RWMutex
	lockWaitAllow sync.RWMutex
}

// Release calls ReleaseFunc.
func (mock *StreamsLimiterMock) Release() {
	if mock.ReleaseFunc == nil {
		panic("StreamsLimiterMock.ReleaseFunc: method is nil but StreamsLimiter.Release was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRelease.Lock()
	mock.calls.Release = append(mock.calls.Release, callInfo)
	mock.lockRelease.Unlock()
	mock.ReleaseFunc()
}

// ReleaseCalls gets all the calls that were made to Release.
// Check the length with:
//
//	len(mockedStreamsLimiter.ReleaseCalls())
func (mock *StreamsLimiterMock) ReleaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRelease.RLock()
	calls = mock.calls.Release
	mock.lockRelease.RUnlock()
	return calls
}

// WaitAllow calls WaitAllowFunc.
func (mock *StreamsLimiterMock) WaitAllow() {
	if mock.WaitAllowFunc == nil {
		panic("StreamsLimiterMock.WaitAllowFunc: method is nil but StreamsLimiter.WaitAllow was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWaitAllow.Lock()
	mock.calls.WaitAllow = append(mock.calls.WaitAllow, callInfo)
	mock.lockWaitAllow.Unlock()
	mock.WaitAllowFunc()
}

// WaitAllowCalls gets all the calls that were made to WaitAllow.
// Check the length with:
//
//	len(mockedStreamsLimiter.WaitAllowCalls())
func (mock *StreamsLimiterMock) WaitAllowCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWaitAllow.RLock()
	calls = mock.calls.WaitAllow
	mock.lockWaitAllow.RUnlock()
	return calls
}

// Ensure, that StreamMock does implement types.Stream.
// If this is not the case, regenerate this file with moq.
var _ types.Stream = &StreamMock{}

// StreamMock is a mock implementation of types.Stream.
//
//	func TestSomethingThatUsesStream(t *testing.T) {
//
//		// make and configure a mocked types.Stream
//		mockedStream := &StreamMock{
//			EndFunc: func()  {
//				panic("mock out the End method")
//			},
//			FCFunc: func() types.FlowControl {
//				panic("mock out the FC method")
//			},
//			FirstByteSentFunc: func()  {
//				panic("mock out the FirstByteSent method")
//			},
//			GoAwayFunc: func(code http2.ErrCode, debugData []byte)  {
//				panic("mock out the GoAway method")
//			},
//			IDFunc: func() uint32 {
//				panic("mock out the ID method")
//			},
//			IoErrorFunc: func(err error)  {
//				panic("mock out the IoError method")
//			},
//			LastByteSentFunc: func()  {
//				panic("mock out the LastByteSent method")
//			},
//			OnHeaderFunc: func(name string, value string)  {
//				panic("mock out the OnHeader method")
//			},
//			RSTStreamFunc: func(code http2.ErrCode)  {
//				panic("mock out the RSTStream method")
//			},
//			RequestErrorFunc: func(err error)  {
//				panic("mock out the RequestError method")
//			},
//			SetSizeFunc: func(n int)  {
//				panic("mock out the SetSize method")
//			},
//			TimeoutFunc: func()  {
//				panic("mock out the Timeout method")
//			},
//		}
//
//		// use mockedStream in code that requires types.Stream
//		// and then make assertions.
//
//	}
type StreamMock struct {
	// EndFunc mocks the End method.
	EndFunc func()

	// FCFunc mocks the FC method.
	FCFunc func() types.FlowControl

	// FirstByteSentFunc mocks the FirstByteSent method.
	FirstByteSentFunc func()

	// GoAwayFunc mocks the GoAway method.
	GoAwayFunc func(code http2.ErrCode, debugData []byte)

	// IDFunc mocks the ID method.
	IDFunc func() uint32

	// IoErrorFunc mocks the IoError method.
	IoErrorFunc func(err error)

	// LastByteSentFunc mocks the LastByteSent method.
	LastByteSentFunc func()

	// OnHeaderFunc mocks the OnHeader method.
	OnHeaderFunc func(name string, value string)

	// RSTStreamFunc mocks the RSTStream method.
	RSTStreamFunc func(code http2.ErrCode)

	// RequestErrorFunc mocks the RequestError method.
	RequestErrorFunc func(err error)

	// SetSizeFunc mocks the SetSize method.
	SetSizeFunc func(n int)

	// TimeoutFunc mocks the Timeout method.
	TimeoutFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// End holds details about calls to the End method.
		End []struct {
		}
		// FC holds details about calls to the FC method.
		FC []struct {
		}
		// FirstByteSent holds details about calls to the FirstByteSent method.
		FirstByteSent []struct {
		}
		// GoAway holds details about calls to the GoAway method.
		GoAway []struct {
			// Code is the code argument value.
			Code http2.ErrCode
			// DebugData is the debugData argument value.
			DebugData []byte
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// IoError holds details about calls to the IoError method.
		IoError []struct {
			// Err is the err argument value.
			Err error
		}
		// LastByteSent holds details about calls to the LastByteSent method.
		LastByteSent []struct {
		}
		// OnHeader holds details about calls to the OnHeader method.
		OnHeader []struct {
			// Name is the name argument value.
			Name string
			// Value is the value argument value.
			Value string
		}
		// RSTStream holds details about calls to the RSTStream method.
		RSTStream []struct {
			// Code is the code argument value.
			Code http2.ErrCode
		}
		// RequestError holds details about calls to the RequestError method.
		RequestError []struct {
			// Err is the err argument value.
			Err error
		}
		// SetSize holds details about calls to the SetSize method.
		SetSize []struct {
			// N is the n argument value.
			N int
		}
		// Timeout holds details about calls to the Timeout method.
		Timeout []struct {
		}
	}
	lockEnd           sync.RWMutex
	lockFC            sync.RWMutex
	lockFirstByteSent sync.RWMutex
	lockGoAway        sync.RWMutex
	lockID            sync.RWMutex
	lockIoError       sync.RWMutex
	lockLastByteSent  sync.RWMutex
	lockOnHeader      sync.RWMutex
	lockRSTStream     sync.RWMutex
	lockRequestError  sync.RWMutex
	lockSetSize       sync.RWMutex
	lockTimeout       sync.RWMutex
}

// End calls EndFunc.
func (mock *StreamMock) End() {
	if mock.EndFunc == nil {
		panic("StreamMock.EndFunc: method is nil but Stream.End was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEnd.Lock()
	mock.calls.End = append(mock.calls.End, callInfo)
	mock.lockEnd.Unlock()
	mock.EndFunc()
}

// EndCalls gets all the calls that were made to End.
// Check the length with:
//
//	len(mockedStream.EndCalls())
func (mock *StreamMock) EndCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEnd.RLock()
	calls = mock.calls.End
	mock.lockEnd.RUnlock()
	return calls
}

// FC calls FCFunc.
func (mock *StreamMock) FC() types.FlowControl {
	if mock.FCFunc == nil {
		panic("StreamMock.FCFunc: method is nil but Stream.FC was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFC.Lock()
	mock.calls.FC = append(mock.calls.FC, callInfo)
	mock.lockFC.Unlock()
	return mock.FCFunc()
}

// FCCalls gets all the calls that were made to FC.
// Check the length with:
//
//	len(mockedStream.FCCalls())
func (mock *StreamMock) FCCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFC.RLock()
	calls = mock.calls.FC
	mock.lockFC.RUnlock()
	return calls
}

// FirstByteSent calls FirstByteSentFunc.
func (mock *StreamMock) FirstByteSent() {
	if mock.FirstByteSentFunc == nil {
		panic("StreamMock.FirstByteSentFunc: method is nil but Stream.FirstByteSent was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFirstByteSent.Lock()
	mock.calls.FirstByteSent = append(mock.calls.FirstByteSent, callInfo)
	mock.lockFirstByteSent.Unlock()
	mock.FirstByteSentFunc()
}

// FirstByteSentCalls gets all the calls that were made to FirstByteSent.
// Check the length with:
//
//	len(mockedStream.FirstByteSentCalls())
func (mock *StreamMock) FirstByteSentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFirstByteSent.RLock()
	calls = mock.calls.FirstByteSent
	mock.lockFirstByteSent.RUnlock()
	return calls
}

// GoAway calls GoAwayFunc.
func (mock *StreamMock) GoAway(code http2.ErrCode, debugData []byte) {
	if mock.GoAwayFunc == nil {
		panic("StreamMock.GoAwayFunc: method is nil but Stream.GoAway was just called")
	}
	callInfo := struct {
		Code      http2.ErrCode
		DebugData []byte
	}{
		Code:      code,
		DebugData: debugData,
	}
	mock.lockGoAway.Lock()
	mock.calls.GoAway = append(mock.calls.GoAway, callInfo)
	mock.lockGoAway.Unlock()
	mock.GoAwayFunc(code, debugData)
}

// GoAwayCalls gets all the calls that were made to GoAway.
// Check the length with:
//
//	len(mockedStream.GoAwayCalls())
func (mock *StreamMock) GoAwayCalls() []struct {
	Code      http2.ErrCode
	DebugData []byte
} {
	var calls []struct {
		Code      http2.ErrCode
		DebugData []byte
	}
	mock.lockGoAway.RLock()
	calls = mock.calls.GoAway
	mock.lockGoAway.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *StreamMock) ID() uint32 {
	if mock.IDFunc == nil {
		panic("StreamMock.IDFunc: method is nil but Stream.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedStream.IDCalls())
func (mock *StreamMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// IoError calls IoErrorFunc.
func (mock *StreamMock) IoError(err error) {
	if mock.IoErrorFunc == nil {
		panic("StreamMock.IoErrorFunc: method is nil but Stream.IoError was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockIoError.Lock()
	mock.calls.IoError = append(mock.calls.IoError, callInfo)
	mock.lockIoError.Unlock()
	mock.IoErrorFunc(err)
}

// IoErrorCalls gets all the calls that were made to IoError.
// Check the length with:
//
//	len(mockedStream.IoErrorCalls())
func (mock *StreamMock) IoErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockIoError.RLock()
	calls = mock.calls.IoError
	mock.lockIoError.RUnlock()
	return calls
}

// LastByteSent calls LastByteSentFunc.
func (mock *StreamMock) LastByteSent() {
	if mock.LastByteSentFunc == nil {
		panic("StreamMock.LastByteSentFunc: method is nil but Stream.LastByteSent was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastByteSent.Lock()
	mock.calls.LastByteSent = append(mock.calls.LastByteSent, callInfo)
	mock.lockLastByteSent.Unlock()
	mock.LastByteSentFunc()
}

// LastByteSentCalls gets all the calls that were made to LastByteSent.
// Check the length with:
//
//	len(mockedStream.LastByteSentCalls())
func (mock *StreamMock) LastByteSentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastByteSent.RLock()
	calls = mock.calls.LastByteSent
	mock.lockLastByteSent.RUnlock()
	return calls
}

// OnHeader calls OnHeaderFunc.
func (mock *StreamMock) OnHeader(name string, value string) {
	if mock.OnHeaderFunc == nil {
		panic("StreamMock.OnHeaderFunc: method is nil but Stream.OnHeader was just called")
	}
	callInfo := struct {
		Name  string
		Value string
	}{
		Name:  name,
		Value: value,
	}
	mock.lockOnHeader.Lock()
	mock.calls.OnHeader = append(mock.calls.OnHeader, callInfo)
	mock.lockOnHeader.Unlock()
	mock.OnHeaderFunc(name, value)
}

// OnHeaderCalls gets all the calls that were made to OnHeader.
// Check the length with:
//
//	len(mockedStream.OnHeaderCalls())
func (mock *StreamMock) OnHeaderCalls() []struct {
	Name  string
	Value string
} {
	var calls []struct {
		Name  string
		Value string
	}
	mock.lockOnHeader.RLock()
	calls = mock.calls.OnHeader
	mock.lockOnHeader.RUnlock()
	return calls
}

// RSTStream calls RSTStreamFunc.
func (mock *StreamMock) RSTStream(code http2.ErrCode) {
	if mock.RSTStreamFunc == nil {
		panic("StreamMock.RSTStreamFunc: method is nil but Stream.RSTStream was just called")
	}
	callInfo := struct {
		Code http2.ErrCode
	}{
		Code: code,
	}
	mock.lockRSTStream.Lock()
	mock.calls.RSTStream = append(mock.calls.RSTStream, callInfo)
	mock.lockRSTStream.Unlock()
	mock.RSTStreamFunc(code)
}

// RSTStreamCalls gets all the calls that were made to RSTStream.
// Check the length with:
//
//	len(mockedStream.RSTStreamCalls())
func (mock *StreamMock) RSTStreamCalls() []struct {
	Code http2.ErrCode
} {
	var calls []struct {
		Code http2.ErrCode
	}
	mock.lockRSTStream.RLock()
	calls = mock.calls.RSTStream
	mock.lockRSTStream.RUnlock()
	return calls
}

// RequestError calls RequestErrorFunc.
func (mock *StreamMock) RequestError(err error) {
	if mock.RequestErrorFunc == nil {
		panic("StreamMock.RequestErrorFunc: method is nil but Stream.RequestError was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockRequestError.Lock()
	mock.calls.RequestError = append(mock.calls.RequestError, callInfo)
	mock.lockRequestError.Unlock()
	mock.RequestErrorFunc(err)
}

// RequestErrorCalls gets all the calls that were made to RequestError.
// Check the length with:
//
//	len(mockedStream.RequestErrorCalls())
func (mock *StreamMock) RequestErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockRequestError.RLock()
	calls = mock.calls.RequestError
	mock.lockRequestError.RUnlock()
	return calls
}

// SetSize calls SetSizeFunc.
func (mock *StreamMock) SetSize(n int) {
	if mock.SetSizeFunc == nil {
		panic("StreamMock.SetSizeFunc: method is nil but Stream.SetSize was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockSetSize.Lock()
	mock.calls.SetSize = append(mock.calls.SetSize, callInfo)
	mock.lockSetSize.Unlock()
	mock.SetSizeFunc(n)
}

// SetSizeCalls gets all the calls that were made to SetSize.
// Check the length with:
//
//	len(mockedStream.SetSizeCalls())
func (mock *StreamMock) SetSizeCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockSetSize.RLock()
	calls = mock.calls.SetSize
	mock.lockSetSize.RUnlock()
	return calls
}

// Timeout calls TimeoutFunc.
func (mock *StreamMock) Timeout() {
	if mock.TimeoutFunc == nil {
		panic("StreamMock.TimeoutFunc: method is nil but Stream.Timeout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTimeout.Lock()
	mock.calls.Timeout = append(mock.calls.Timeout, callInfo)
	mock.lockTimeout.Unlock()
	mock.TimeoutFunc()
}

// TimeoutCalls gets all the calls that were made to Timeout.
// Check the length with:
//
//	len(mockedStream.TimeoutCalls())
func (mock *StreamMock) TimeoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTimeout.RLock()
	calls = mock.calls.Timeout
	mock.lockTimeout.RUnlock()
	return calls
}

// Ensure, that FlowControlMock does implement types.FlowControl.
// If this is not the case, regenerate this file with moq.
var _ types.FlowControl = &FlowControlMock{}

// FlowControlMock is a mock implementation of types.FlowControl.
//
//	func TestSomethingThatUsesFlowControl(t *testing.T) {
//
//		// make and configure a mocked types.FlowControl
//		mockedFlowControl := &FlowControlMock{
//			AddFunc: func(n uint32)  {
//				panic("mock out the Add method")
//			},
//			DisableFunc: func()  {
//				panic("mock out the Disable method")
//			},
//			ResetFunc: func(n uint32)  {
//				panic("mock out the Reset method")
//			},
//			WaitFunc: func(n uint32) bool {
//				panic("mock out the Wait method")
//			},
//		}
//
//		// use mockedFlowControl in code that requires types.FlowControl
//		// and then make assertions.
//
//	}
type FlowControlMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(n uint32)

	// DisableFunc mocks the Disable method.
	DisableFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func(n uint32)

	// WaitFunc mocks the Wait method.
	WaitFunc func(n uint32) bool

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// N is the n argument value.
			N uint32
		}
		// Disable holds details about calls to the Disable method.
		Disable []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
			// N is the n argument value.
			N uint32
		}
		// Wait holds details about calls to the Wait method.
		Wait []struct {
			// N is the n argument value.
			N uint32
		}
	}
	lockAdd     sync.RWMutex
	lockDisable sync.RWMutex
	lockReset   sync.RWMutex
	lockWait    sync.RWMutex
}

// Add calls AddFunc.
func (mock *FlowControlMock) Add(n uint32) {
	if mock.AddFunc == nil {
		panic("FlowControlMock.AddFunc: method is nil but FlowControl.Add was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	mock.AddFunc(n)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedFlowControl.AddCalls())
func (mock *FlowControlMock) AddCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Disable calls DisableFunc.
func (mock *FlowControlMock) Disable() {
	if mock.DisableFunc == nil {
		panic("FlowControlMock.DisableFunc: method is nil but FlowControl.Disable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDisable.Lock()
	mock.calls.Disable = append(mock.calls.Disable, callInfo)
	mock.lockDisable.Unlock()
	mock.DisableFunc()
}

// DisableCalls gets all the calls that were made to Disable.
// Check the length with:
//
//	len(mockedFlowControl.DisableCalls())
func (mock *FlowControlMock) DisableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDisable.RLock()
	calls = mock.calls.Disable
	mock.lockDisable.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *FlowControlMock) Reset(n uint32) {
	if mock.ResetFunc == nil {
		panic("FlowControlMock.ResetFunc: method is nil but FlowControl.Reset was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc(n)
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedFlowControl.ResetCalls())
func (mock *FlowControlMock) ResetCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// Wait calls WaitFunc.
func (mock *FlowControlMock) Wait(n uint32) bool {
	if mock.WaitFunc == nil {
		panic("FlowControlMock.WaitFunc: method is nil but FlowControl.Wait was just called")
	}
	callInfo := struct {
		N uint32
	}{
		N: n,
	}
	mock.lockWait.Lock()
	mock.calls.Wait = append(mock.calls.Wait, callInfo)
	mock.lockWait.Unlock()
	return mock.WaitFunc(n)
}

// WaitCalls gets all the calls that were made to Wait.
// Check the length with:
//
//	len(mockedFlowControl.WaitCalls())
func (mock *FlowControlMock) WaitCalls() []struct {
	N uint32
} {
	var calls []struct {
		N uint32
	}
	mock.lockWait.RLock()
	calls = mock.calls.Wait
	mock.lockWait.RUnlock()
	return calls
}
